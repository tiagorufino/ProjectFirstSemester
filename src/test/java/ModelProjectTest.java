package test.java;


import javax.swing.JFrame;

import org.junit.Assert;
import org.junit.Test;

import main.java.commons.AppConstants;
import main.java.facade.ModelProject;
import main.java.facade.ModelProjectImpl;

/**
 * Test class of the model class. 
 * @author Tiago Rufino
 */
public class ModelProjectTest {	
	
	ModelProject modelProjectInterface = new ModelProjectImpl();
	
	/**
	 * Call the test. First encrypt the decrypt
	 */
	@Test
	public void testOne (){
		
		String base = mountBase();
		String[] input = mountInput(base);
		String[] encode = mountEncode(base);
		String[] outputs = new String[AppConstants.Numbers.TEN];
		String[] errors = new String[AppConstants.Numbers.TEN];
		
		
		String[][] mapBufferEncrypter = encryptTest(input, encode);
		
		//Encrypting
		for (int i = AppConstants.Numbers.ZERO; i < outputs.length; i++) {
			outputs[i] = mapBufferEncrypter[i][AppConstants.Numbers.ZERO];
			errors[i] = mapBufferEncrypter[i][AppConstants.Numbers.ONE];
		}
		
		//Decrypting
		String[][] mapBufferDecrypter = decryptTest(outputs, input, encode);

		for (int i = AppConstants.Numbers.ZERO; i < outputs.length; i++) {
			Assert.assertEquals(input[i], mapBufferDecrypter[i][AppConstants.Numbers.ZERO]);
			errors[i] = mapBufferDecrypter[i][AppConstants.Numbers.ONE];
		}
		
		modelProjectInterface.exceptions(errors, new JFrame());
		modelProjectInterface.exceptions(null, new JFrame());
		
	}
	
	@Test
	public void testTwo (){
		String input = AppConstants.BASE_JAPONESE;
		String encode = modelProjectInterface.shuffleString();
		String[] outputs;
		
		
		outputs = modelProjectInterface.encryptDecrypt(input, AppConstants.BASE, encode);
		
		//Decrypting
		String[] mapBufferDecrypter= modelProjectInterface.
				encryptDecrypt(outputs[AppConstants.Numbers.ONE], encode, AppConstants.BASE);
		
		Assert.assertNotEquals(outputs, mapBufferDecrypter[AppConstants.Numbers.ZERO]);
		
		modelProjectInterface.exceptions(outputs, new JFrame());
	}
	
	@Test
	public void testError (){
		String base = mountBase();
		String[] input = mountInput(base);
		String[] encode = mountEncode(base);
		String[] outputs = new String[AppConstants.Numbers.TEN];
		String[] errors = new String[AppConstants.Numbers.TEN];
		
		
		String[][] mapBufferEncrypter = encryptTest(input, encode);
		
		//Encrypting
		for (int i = AppConstants.Numbers.ZERO; i < outputs.length; i++) {
			outputs[i] = mapBufferEncrypter[i][AppConstants.Numbers.ZERO];
			errors[i] = mapBufferEncrypter[i][AppConstants.Numbers.ONE];
		}
		
		//Decrypting
		String[][] mapBufferDecrypter = decryptTest(outputs, input, encode);

		for (int i = AppConstants.Numbers.ZERO; i < outputs.length; i++) {
			Assert.assertEquals(input[i], mapBufferDecrypter[i][AppConstants.Numbers.ZERO]);
			errors[i] = mapBufferDecrypter[i][AppConstants.Numbers.ONE];
		}
		
	}

	/**
	 * Test the Encrypt method
	 * 
	 * @return String[][] - Return encrypt informations like [result][error]
	 */
	public String[][] encryptTest(String[] input, String[] encode) {
		String [][] buffer = new String[AppConstants.Numbers.TEN][];
		for (int i = AppConstants.Numbers.ZERO; i < input.length; i++) {
			buffer[i] = modelProjectInterface.encryptDecrypt(input[i], AppConstants.BASE, encode[i]);
		}
		return buffer;
	}
	
	/**
	 * Test the Decrypt method
	 *  
	 * @param output - Vector of Strings generated by encrypt information
	 * @return String[][] - REturn decrypt informations like [result][error] 
	 */
	public String[][] decryptTest(String[] output, String[] input, String[] encode) {
		String [][] buffer = new String[AppConstants.Numbers.TEN][];
		for (int i = AppConstants.Numbers.ZERO; i < input.length; i++) {
			buffer[i] = modelProjectInterface.encryptDecrypt(output[i], encode[i], AppConstants.BASE);
		}
		return buffer;
	}
	
	/**
	 * Create the input
	 * 
	 * @param base
	 * @return
	 */
	public String[] mountInput(String base){
		
	    return new String[]{modelProjectInterface.shuffleString().substring(AppConstants.Numbers.ZERO, AppConstants.Numbers.TEN),
	    		modelProjectInterface.shuffleString().substring(AppConstants.Numbers.ZERO, AppConstants.Numbers.TEN),
	    		modelProjectInterface.shuffleString().substring(AppConstants.Numbers.ZERO, AppConstants.Numbers.TEN),
	    		modelProjectInterface.shuffleString().substring(AppConstants.Numbers.ZERO, AppConstants.Numbers.TEN),
	    		modelProjectInterface.shuffleString().substring(AppConstants.Numbers.ZERO, AppConstants.Numbers.TEN),
	    		modelProjectInterface.shuffleString().substring(AppConstants.Numbers.ZERO, AppConstants.Numbers.TEN),
	    		modelProjectInterface.shuffleString().substring(AppConstants.Numbers.ZERO, AppConstants.Numbers.TEN),
	    		modelProjectInterface.shuffleString().substring(AppConstants.Numbers.ZERO, AppConstants.Numbers.TEN),
	    		modelProjectInterface.shuffleString().substring(AppConstants.Numbers.ZERO, AppConstants.Numbers.TEN),
	    		modelProjectInterface.shuffleString().substring(AppConstants.Numbers.ZERO, AppConstants.Numbers.TEN)};
	}
	
	/**
	 * Mount normal base
	 * 
	 * @return
	 */
	public String mountBase(){
		String output = AppConstants.EMPTY;
		for (int i = 33; i <= 126; i++) {
		    char ch = (char) i;
		    output+=ch;
		}
		return output;
	}
	
	/**
	 * Normal Encode
	 * 
	 * @param base
	 * @return
	 */
	public String[] mountEncode(String base){
		return new String[]{modelProjectInterface.shuffleString(),
				modelProjectInterface.shuffleString(),
				modelProjectInterface.shuffleString(),
				modelProjectInterface.shuffleString(),
				modelProjectInterface.shuffleString(),
				modelProjectInterface.shuffleString(),
				modelProjectInterface.shuffleString(),
				modelProjectInterface.shuffleString(),
				modelProjectInterface.shuffleString(),
				modelProjectInterface.shuffleString()
		};
	}
}
